name: Package Builds (Reusable)

on:
  workflow_call:
    inputs:
      version:
        description: 'Version string for package names (empty for dev builds)'
        required: false
        type: string
        default: 'dev'
    outputs:
      windows-artifact:
        description: "Name of Windows artifact"
        value: ${{ jobs.build-windows-package.outputs.artifact-name }}
      macos-artifact:
        description: "Name of macOS artifact"
        value: ${{ jobs.build-macos-package.outputs.artifact-name }}
      flatpak-artifact:
        description: "Name of Flatpak artifact"
        value: ${{ jobs.build-flatpak-package.outputs.artifact-name }}

jobs:
  build-windows-package:
    name: Build Windows Package
    runs-on: windows-latest
    outputs:
      artifact-name: ${{ steps.set-artifact-name.outputs.name }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          lfs: true
      
      - name: Install ImageMagick
        run: choco install imagemagick -y
      
      - name: Install WiX Toolset
        run: |
          choco install wixtoolset -y
          
          # Find WiX installation directory
          $wixPath = Get-ChildItem "C:\Program Files (x86)" -Filter "WiX Toolset*" -Directory | Select-Object -First 1 -ExpandProperty FullName
          if (-not $wixPath) {
            $wixPath = "C:\Program Files (x86)\WiX Toolset v3.14"
          }
          $wixBin = Join-Path $wixPath "bin"
          
          Write-Host "WiX Toolset found at: $wixBin"
          
          # Add WiX to PATH for subsequent steps
          echo "$wixBin" | Out-File -FilePath $env:GITHUB_PATH -Encoding utf8 -Append
          
          # Verify candle.exe is accessible
          if (Test-Path (Join-Path $wixBin "candle.exe")) {
            Write-Host "✓ candle.exe found"
          } else {
            Write-Host "ERROR: candle.exe not found in $wixBin" -ForegroundColor Red
            exit 1
          }
      
      - name: Install Qt6
        uses: jurplel/install-qt-action@v4
        with:
          version: '6.8.1'
          host: 'windows'
          target: 'desktop'
          arch: 'win64_msvc2022_64'
          cache: true
      
      - name: Setup vcpkg binary cache
        uses: actions/cache@v4
        with:
          path: |
            C:/vcpkg/installed
            C:/vcpkg/packages
            C:/Users/runneradmin/AppData/Local/vcpkg/archives
          key: vcpkg-${{ runner.os }}-${{ hashFiles('**/vcpkg.json') }}-${{ hashFiles('.github/workflows/package-builds.yml') }}
          restore-keys: |
            vcpkg-${{ runner.os }}-
      
      - name: Install vcpkg dependencies
        run: |
          vcpkg install --triplet x64-windows --recurse `
            spdlog `
            sqlite3 `
            yaml-cpp `
            libpng `
            fftw3 `
            pkgconf `
            "ffmpeg[x264,x265,vpx,gpl]"
      
      - name: Create build directory
        run: mkdir -p build
      
      - name: Configure CMake
        run: |
          cd build
          cmake .. `
            -DCMAKE_BUILD_TYPE=Release `
            -DBUILD_GUI=ON `
            -DBUILD_TESTS=OFF `
            -DCMAKE_PREFIX_PATH="${env:Qt6_DIR}" `
            -DCMAKE_TOOLCHAIN_FILE=C:/vcpkg/scripts/buildsystems/vcpkg.cmake
      
      - name: Build
        run: |
          cd build
          cmake --build . --config Release -j $env:NUMBER_OF_PROCESSORS
      
      - name: Create RTF license for WiX
        run: |
          # Convert LICENSE to RTF format for WiX
          $licenseContent = Get-Content -Path "LICENSE" -Raw
          
          # Create simple RTF file with license text
          $rtfHeader = "{\rtf1\ansi\deff0 {\fonttbl {\f0 Courier New;}}\f0\fs18"
          $rtfFooter = "}"
          
          # Escape special RTF characters and convert to RTF
          $licenseRtf = $licenseContent -replace '\\', '\\\\' -replace '{', '\{' -replace '}', '\}' -replace "`n", "\par`n"
          
          $fullRtf = $rtfHeader + "`n" + $licenseRtf + "`n" + $rtfFooter
          
          # Save to build directory (CMAKE_BINARY_DIR is the root build directory)
          $fullRtf | Out-File -FilePath "build/LICENSE.rtf" -Encoding ASCII
          
          Write-Host "Created LICENSE.rtf for WiX installer"
      
      - name: Generate MSI installer with CPack
        run: |
          cd build
          
          # Run CPack to generate the MSI with verbose output
          cpack -C Release -G WIX --verbose 2>&1 | Tee-Object -FilePath cpack-output.log
          $CPACK_RESULT = $LASTEXITCODE
          
          if ($CPACK_RESULT -ne 0) {
            Write-Host "`nCPack failed. Checking for WiX log..." -ForegroundColor Red
            $logPath = "_CPack_Packages/win64/WIX/wix.log"
            if (Test-Path $logPath) {
              Write-Host "`nWiX Log Contents:" -ForegroundColor Yellow
              Get-Content $logPath
            }
            exit 1
          }
          
          # Show install-related messages from CPack output
          Write-Host "`nSearching for install messages in CPack output:" -ForegroundColor Cyan
          Get-Content cpack-output.log | Select-String -Pattern "(windeployqt|Installing|vcpkg|yaml-cpp|Qt6)" | ForEach-Object { Write-Host $_ }
          
          # Verify DLLs were deployed correctly
          $stagingDir = Get-ChildItem -Path "_CPack_Packages/win64/WIX" -Filter "Decode Orc-*" -Directory -ErrorAction SilentlyContinue | Select-Object -First 1
          if ($stagingDir) {
            Write-Host "`nVerifying deployed DLLs in MSI package:" -ForegroundColor Cyan
            $binPath = Join-Path $stagingDir.FullName "bin"
            
            if (Test-Path $binPath) {
              # Check for Qt DLLs
              $qtDlls = Get-ChildItem -Path $binPath -Filter "Qt6*.dll" -ErrorAction SilentlyContinue
              Write-Host "`nQt DLLs:" -ForegroundColor Yellow
              if ($qtDlls) {
                $qtDlls | ForEach-Object { Write-Host "  $($_.Name)" }
              } else {
                Write-Host "  (none found)" -ForegroundColor Red
              }
              
              # Check for vcpkg DLLs
              $vcpkgDlls = @("yaml-cpp.dll", "spdlog.dll", "fftw3.dll", "libpng16.dll", "sqlite3.dll")
              Write-Host "`nvcpkg DLLs:" -ForegroundColor Yellow
              foreach ($dll in $vcpkgDlls) {
                if (Test-Path (Join-Path $binPath $dll)) {
                  Write-Host "  ✓ $dll" -ForegroundColor Green
                } else {
                  Write-Host "  ✗ $dll MISSING" -ForegroundColor Red
                }
              }
              
              # List all DLLs
              Write-Host "`nAll DLLs in package:" -ForegroundColor Yellow
              $allDlls = Get-ChildItem -Path $binPath -Filter "*.dll" -ErrorAction SilentlyContinue
              if ($allDlls) {
                $allDlls | Format-Table Name, Length -AutoSize
              } else {
                Write-Host "  (no DLLs found)" -ForegroundColor Red
              }
              
              # List all files
              Write-Host "`nAll files in bin:" -ForegroundColor Yellow
              Get-ChildItem -Path $binPath | Format-Table Name -AutoSize
            } else {
              Write-Host "`nERROR: bin directory does not exist at: $binPath" -ForegroundColor Red
              Write-Host "`nStaging directory contents:" -ForegroundColor Yellow
              Get-ChildItem -Path $stagingDir.FullName -Recurse | Format-Table FullName -AutoSize
            }
          } else {
            Write-Host "`nERROR: Could not find staging directory" -ForegroundColor Red
          }
          
          # List generated packages
          Write-Host "`nGenerated installer packages:"
          Get-ChildItem -Filter "*.msi"
      
      - name: Set artifact name
        id: set-artifact-name
        shell: bash
        run: |
          if [ "${{ inputs.version }}" = "dev" ]; then
            echo "name=decode-orc-windows" >> $GITHUB_OUTPUT
          else
            echo "name=windows-installer" >> $GITHUB_OUTPUT
          fi
      
      - name: Upload Windows MSI installer
        uses: actions/upload-artifact@v4
        with:
          name: ${{ steps.set-artifact-name.outputs.name }}
          path: build/*.msi
          retention-days: 7

  build-macos-package:
    name: Build macOS Package
    runs-on: macos-latest
    outputs:
      artifact-name: ${{ steps.set-artifact-name.outputs.name }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          lfs: true
      
      - name: Install system dependencies
        run: |
          brew update || true
          brew install --quiet \
            cmake \
            pkg-config \
            spdlog \
            sqlite \
            yaml-cpp \
            libpng \
            fftw \
            qt@6 \
            create-dmg \
            ffmpeg 2>&1 | grep -v "is already installed" || true
      
      - name: Create build directory
        run: mkdir -p build
      
      - name: Configure CMake
        run: |
          cd build
          export HOMEBREW_PREFIX=$(brew --prefix)
          export Qt6_DIR=$HOMEBREW_PREFIX/opt/qt@6/lib/cmake/Qt6
          cmake .. \
            -DCMAKE_BUILD_TYPE=Release \
            -DBUILD_GUI=ON \
            -DBUILD_TESTS=OFF \
            -DCMAKE_PREFIX_PATH="$HOMEBREW_PREFIX" \
            -DQt6_DIR=$Qt6_DIR \
            -DCMAKE_OSX_DEPLOYMENT_TARGET=11.0
      
      - name: Build
        run: |
          cd build
          cmake --build . -j$(sysctl -n hw.ncpu)
      
      - name: Create app bundle
        run: |
          mkdir -p "orc-gui.app/Contents/MacOS"
          mkdir -p "orc-gui.app/Contents/Resources"
          
          # Copy executables
          cp build/bin/orc-gui "orc-gui.app/Contents/MacOS/"
          cp build/bin/orc-cli "orc-gui.app/Contents/MacOS/"
          
          # Use CMake-generated icon if available, otherwise create from PNG
          if [ -f "build/orc/gui/icons/orc-gui.icns" ]; then
            echo "Using CMake-generated icon"
            cp "build/orc/gui/icons/orc-gui.icns" "orc-gui.app/Contents/Resources/orc-gui-icon.icns"
            cp "build/orc/gui/icons/orc-gui.icns" ".VolumeIcon.icns"
          else
            echo "CMake icon not found, generating from PNG"
            mkdir -p orc-gui.iconset
            
            # Use the 256x256 PNG as source (better quality than converting from SVG with rsvg)
            SOURCE_PNG="assets/orc-gui-icon-256.png"
            
            # Use sips to resize to all needed sizes for .icns
            # Note: sips handles alpha channel properly for macOS icons
            sips -z 16 16     "$SOURCE_PNG" --out orc-gui.iconset/icon_16x16.png
            sips -z 32 32     "$SOURCE_PNG" --out orc-gui.iconset/icon_16x16@2x.png
            sips -z 32 32     "$SOURCE_PNG" --out orc-gui.iconset/icon_32x32.png
            sips -z 64 64     "$SOURCE_PNG" --out orc-gui.iconset/icon_32x32@2x.png
            sips -z 128 128   "$SOURCE_PNG" --out orc-gui.iconset/icon_128x128.png
            sips -z 256 256   "$SOURCE_PNG" --out orc-gui.iconset/icon_128x128@2x.png
            sips -z 256 256   "$SOURCE_PNG" --out orc-gui.iconset/icon_256x256.png
            sips -z 512 512   "$SOURCE_PNG" --out orc-gui.iconset/icon_256x256@2x.png
            sips -z 512 512   "$SOURCE_PNG" --out orc-gui.iconset/icon_512x512.png
            sips -z 1024 1024 "$SOURCE_PNG" --out orc-gui.iconset/icon_512x512@2x.png
            
            # Convert iconset to icns
            iconutil -c icns orc-gui.iconset -o "orc-gui.app/Contents/Resources/orc-gui-icon.icns"
            iconutil -c icns orc-gui.iconset -o ".VolumeIcon.icns"
            
            echo "Generated icon from PNG"
          fi
          
          # Create PkgInfo
          echo "APPL????" > "orc-gui.app/Contents/PkgInfo"
          
          # Create Info.plist
          cat > "orc-gui.app/Contents/Info.plist" << 'EOF'
          <?xml version="1.0" encoding="UTF-8"?>
          <!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
          <plist version="1.0">
          <dict>
            <key>CFBundleExecutable</key>
            <string>orc-gui</string>
            <key>CFBundleIdentifier</key>
            <string>io.github.simoninns.decode-orc</string>
            <key>CFBundleName</key>
            <string>Decode Orc</string>
            <key>CFBundleDisplayName</key>
            <string>Decode Orc</string>
            <key>CFBundleVersion</key>
            <string>1.0</string>
            <key>CFBundleShortVersionString</key>
            <string>1.0</string>
            <key>CFBundlePackageType</key>
            <string>APPL</string>
            <key>CFBundleIconFile</key>
            <string>orc-gui-icon.icns</string>
            <key>CFBundleIconName</key>
            <string>orc-gui-icon</string>
            <key>LSMinimumSystemVersion</key>
            <string>11.0</string>
            <key>NSHighResolutionCapable</key>
            <true/>
            <key>NSPrincipalClass</key>
            <string>NSApplication</string>
          </dict>
          </plist>
          EOF
          
          # Verify the icon file is correctly named and in place
          if [ -f "orc-gui.app/Contents/Resources/orc-gui-icon.icns" ]; then
            echo "✓ App icon properly installed at Resources/orc-gui-icon.icns"
            ls -lh "orc-gui.app/Contents/Resources/orc-gui-icon.icns"
            
            # Set proper file attributes for the icon
            SetFile -a C "orc-gui.app" 2>/dev/null || true
            
            # Verify icon has all required sizes
            echo "Verifying icon contains all required sizes..."
            sips -g allProperties "orc-gui.app/Contents/Resources/orc-gui-icon.icns" | grep -E "pixelWidth|pixelHeight" || echo "Note: Could not verify icon dimensions, but icon file exists"
          else
            echo "ERROR: Icon file not found!"
            exit 1
          fi
      
      - name: Deploy Qt dependencies
        run: |
          HOMEBREW_PREFIX=$(brew --prefix)
          QT_LIB="$HOMEBREW_PREFIX/opt/qt@6/lib"
          
          # Run macdeployqt to bundle Qt frameworks
          echo "Running macdeployqt..."
          $HOMEBREW_PREFIX/opt/qt@6/bin/macdeployqt "orc-gui.app" -verbose=2
          
          # Check for missing Qt dependencies and bundle them
          echo "Checking for missing Qt dependencies..."
          MISSING_FRAMEWORKS=""
          
          if ! [ -d "orc-gui.app/Contents/Frameworks/QtDBus.framework" ]; then
            if otool -L "orc-gui.app/Contents/Frameworks/QtGui.framework/Versions/A/QtGui" 2>/dev/null | grep -q "QtDBus"; then
              echo "QtDBus is required by QtGui but not bundled - adding it"
              MISSING_FRAMEWORKS="QtDBus"
            fi
          fi
          
          # Bundle any missing frameworks and their dependencies
          for framework in $MISSING_FRAMEWORKS; do
            if [ -d "$QT_LIB/${framework}.framework" ]; then
              echo "Copying ${framework}.framework..."
              ditto "$QT_LIB/${framework}.framework" "orc-gui.app/Contents/Frameworks/${framework}.framework"
              
              install_name_tool -id "@rpath/${framework}.framework/Versions/A/${framework}" \
                "orc-gui.app/Contents/Frameworks/${framework}.framework/Versions/A/${framework}"
              
              install_name_tool -change \
                "$QT_LIB/QtCore.framework/Versions/A/QtCore" \
                "@rpath/QtCore.framework/Versions/A/QtCore" \
                "orc-gui.app/Contents/Frameworks/${framework}.framework/Versions/A/${framework}" 2>/dev/null || true
              
              # QtDBus depends on libdbus-1 - bundle it if needed
              if [ "$framework" = "QtDBus" ]; then
                echo "Bundling QtDBus dependencies..."
                DBUS_LIB=$(find $HOMEBREW_PREFIX/opt/dbus/lib -name "libdbus-1.*.dylib" -type f | head -n 1)
                if [ -n "$DBUS_LIB" ]; then
                  DBUS_NAME=$(basename "$DBUS_LIB")
                  echo "Copying $DBUS_NAME..."
                  cp "$DBUS_LIB" "orc-gui.app/Contents/Frameworks/"
                  
                  install_name_tool -id "@rpath/$DBUS_NAME" \
                    "orc-gui.app/Contents/Frameworks/$DBUS_NAME"
                  
                  install_name_tool -change \
                    "$DBUS_LIB" \
                    "@rpath/$DBUS_NAME" \
                    "orc-gui.app/Contents/Frameworks/QtDBus.framework/Versions/A/QtDBus" 2>/dev/null || true
                  
                  for DBUS_PATH in $(otool -L "orc-gui.app/Contents/Frameworks/QtDBus.framework/Versions/A/QtDBus" 2>/dev/null | grep "dbus" | awk '{print $1}'); do
                    install_name_tool -change \
                      "$DBUS_PATH" \
                      "@rpath/$DBUS_NAME" \
                      "orc-gui.app/Contents/Frameworks/QtDBus.framework/Versions/A/QtDBus" 2>/dev/null || true
                  done
                fi
              fi
            fi
          done
          
          # Fix QtGui to reference the bundled QtDBus
          if [ -d "orc-gui.app/Contents/Frameworks/QtDBus.framework" ]; then
            echo "Fixing QtGui references to QtDBus..."
            install_name_tool -change \
              "$QT_LIB/QtDBus.framework/Versions/A/QtDBus" \
              "@rpath/QtDBus.framework/Versions/A/QtDBus" \
              "orc-gui.app/Contents/Frameworks/QtGui.framework/Versions/A/QtGui" 2>/dev/null || true
          fi
          
          echo "Bundled Qt frameworks:"
          ls -la "orc-gui.app/Contents/Frameworks/" | grep "\.framework" || true
      
      - name: Bundle additional dependencies
        run: |
          HOMEBREW_PREFIX=$(brew --prefix)
          
          # Add correct rpath to both executables for bundled frameworks
          echo "Adding @executable_path/../Frameworks to executable rpaths..."
          for EXE in "orc-gui.app/Contents/MacOS/orc-gui" "orc-gui.app/Contents/MacOS/orc-cli"; do
            if ! otool -l "$EXE" | grep -q "@executable_path/../Frameworks"; then
              install_name_tool -add_rpath "@executable_path/../Frameworks" "$EXE"
              echo "  Added to $(basename $EXE)"
            else
              echo "  $(basename $EXE) already has correct rpath"
            fi
          done
          
          # Find and copy libsharpyuv (dependency of libwebp)
          # libsharpyuv is part of the webp package but may be in different locations
          SHARPYUV_LIB=$(find $HOMEBREW_PREFIX/opt/webp/lib $HOMEBREW_PREFIX/Cellar/webp/*/lib $HOMEBREW_PREFIX/lib -name "libsharpyuv.*.dylib" 2>/dev/null | head -n 1)
          if [ -n "$SHARPYUV_LIB" ] && [ -f "$SHARPYUV_LIB" ]; then
            SHARPYUV_NAME=$(basename "$SHARPYUV_LIB")
            echo "Found libsharpyuv at: $SHARPYUV_LIB"
            echo "Copying $SHARPYUV_NAME to bundle..."
            cp "$SHARPYUV_LIB" "orc-gui.app/Contents/Frameworks/"
            chmod 644 "orc-gui.app/Contents/Frameworks/$SHARPYUV_NAME"
            
            # Fix the library ID
            install_name_tool -id "@rpath/$SHARPYUV_NAME" \
              "orc-gui.app/Contents/Frameworks/$SHARPYUV_NAME"
            
            # Fix all libraries that reference libsharpyuv (libwebp, libwebpmux, etc.)
            echo "Fixing references to libsharpyuv in all bundled libraries..."
            for LIB in orc-gui.app/Contents/Frameworks/*.dylib; do
              if otool -L "$LIB" 2>/dev/null | grep -q "libsharpyuv"; then
                echo "  Fixing $(basename $LIB)..."
                
                # Remove the bad @loader_path/../lib rpath if it exists
                if otool -l "$LIB" | grep -A 2 "LC_RPATH" | grep -q "@loader_path/../lib"; then
                  echo "    Removing @loader_path/../lib rpath..."
                  install_name_tool -delete_rpath "@loader_path/../lib" "$LIB" 2>/dev/null || echo "    (delete failed, may not exist)"
                fi
                
                # Add @loader_path rpath so the library can find siblings in same directory
                if ! otool -l "$LIB" | grep -A 2 "LC_RPATH" | grep -q "@loader_path\$"; then
                  echo "    Adding @loader_path rpath..."
                  install_name_tool -add_rpath "@loader_path" "$LIB" 2>/dev/null || echo "    (add failed)"
                fi
                
                for PATH_TO_FIX in $(otool -L "$LIB" 2>/dev/null | grep "libsharpyuv" | awk '{print $1}'); do
                  echo "    Changing $PATH_TO_FIX to @rpath/$SHARPYUV_NAME"
                  install_name_tool -change \
                    "$PATH_TO_FIX" \
                    "@rpath/$SHARPYUV_NAME" \
                    "$LIB" 2>/dev/null || true
                done
                echo "    After fix:"
                otool -L "$LIB" | grep "libsharpyuv" || echo "    No libsharpyuv reference"
              fi
            done
          else
            echo "ERROR: libsharpyuv not found! Searched in:"
            echo "  - $HOMEBREW_PREFIX/opt/webp/lib"
            echo "  - $HOMEBREW_PREFIX/Cellar/webp/*/lib"
            echo "  - $HOMEBREW_PREFIX/lib"
            echo "Listing webp package contents:"
            brew list webp || echo "webp package not installed"
            exit 1
          fi
          
          echo ""
          echo "Bundled libraries:"
          ls -la "orc-gui.app/Contents/Frameworks/" | grep "\.dylib" | head -20
          
          # Find and copy libjxl_cms (dependency of libjxl)
          JXL_CMS_LIB=$(find $HOMEBREW_PREFIX/opt/jpeg-xl/lib $HOMEBREW_PREFIX/Cellar/jpeg-xl/*/lib $HOMEBREW_PREFIX/lib -name "libjxl_cms*.dylib" 2>/dev/null | head -n 1)
          if [ -n "$JXL_CMS_LIB" ] && [ -f "$JXL_CMS_LIB" ]; then
            JXL_CMS_NAME=$(basename "$JXL_CMS_LIB")
            echo "Found libjxl_cms at: $JXL_CMS_LIB"
            echo "Copying $JXL_CMS_NAME to bundle..."
            cp "$JXL_CMS_LIB" "orc-gui.app/Contents/Frameworks/"
            chmod 644 "orc-gui.app/Contents/Frameworks/$JXL_CMS_NAME"
            
            # Fix the library ID
            install_name_tool -id "@rpath/$JXL_CMS_NAME" \
              "orc-gui.app/Contents/Frameworks/$JXL_CMS_NAME"
            
            # Fix all libraries that reference libjxl_cms (mainly libjxl)
            echo "Fixing references to libjxl_cms in all bundled libraries..."
            for LIB in orc-gui.app/Contents/Frameworks/*.dylib; do
              if otool -L "$LIB" 2>/dev/null | grep -q "libjxl_cms"; then
                echo "  Fixing $(basename $LIB)..."
                
                # Add @loader_path rpath so the library can find siblings in same directory
                if ! otool -l "$LIB" | grep -A 2 "LC_RPATH" | grep -q "@loader_path\$"; then
                  echo "    Adding @loader_path rpath..."
                  install_name_tool -add_rpath "@loader_path" "$LIB" 2>/dev/null || echo "    (add failed, may already exist)"
                fi
                
                for PATH_TO_FIX in $(otool -L "$LIB" 2>/dev/null | grep "libjxl_cms" | awk '{print $1}'); do
                  echo "    Changing $PATH_TO_FIX to @rpath/$JXL_CMS_NAME"
                  install_name_tool -change \
                    "$PATH_TO_FIX" \
                    "@rpath/$JXL_CMS_NAME" \
                    "$LIB" 2>/dev/null || true
                done
                echo "    After fix:"
                otool -L "$LIB" | grep "libjxl_cms" || echo "    No libjxl_cms reference"
              fi
            done
          else
            echo "Warning: libjxl_cms not found, but may not be needed"
          fi
          
          echo ""
          echo "Verifying critical dependencies:"
          echo "libsharpyuv in bundle:"
          ls -la "orc-gui.app/Contents/Frameworks/libsharpyuv"* || echo "NOT FOUND!"
          echo "libjxl_cms in bundle:"
          ls -la "orc-gui.app/Contents/Frameworks/libjxl_cms"* || echo "NOT FOUND!"
          echo ""
          echo "Main executable rpaths:"
          otool -l "orc-gui.app/Contents/MacOS/orc-gui" | grep -A 2 LC_RPATH | head -15
          echo ""
          echo "libwebp rpaths:"
          otool -l "orc-gui.app/Contents/Frameworks/libwebp"*.dylib | grep -A 2 LC_RPATH
          echo ""
          echo "libwebp dependencies:"
          otool -L "orc-gui.app/Contents/Frameworks/libwebp"* | grep -E "(libsharpyuv|@rpath)"
          echo ""
          echo "libjxl dependencies:"
          otool -L "orc-gui.app/Contents/Frameworks/libjxl"*.dylib 2>/dev/null | grep -E "(libjxl_cms|@rpath)" || echo "No libjxl found"
      
      - name: Scan and fix all missing dependencies recursively
        run: |
          HOMEBREW_PREFIX=$(brew --prefix)
          
          # This step recursively scans all bundled libraries and executables to find
          # any missing dependencies from homebrew that weren't caught by macdeployqt
          # or the manual bundling steps above. This ensures all transitive dependencies
          # like libjxl_cms (dependency of libjxl) are properly bundled.
          
          echo "Scanning for missing dependencies recursively..."
          
          # Function to get dependencies of a library
          get_dependencies() {
            local lib="$1"
            otool -L "$lib" 2>/dev/null | tail -n +2 | awk '{print $1}' | grep -E "^$HOMEBREW_PREFIX|^@rpath"
          }
          
          # Function to copy a homebrew library to the bundle
          copy_homebrew_lib() {
            local lib_path="$1"
            local lib_name=$(basename "$lib_path")
            
            # Skip if already bundled
            if [ -f "orc-gui.app/Contents/Frameworks/$lib_name" ]; then
              return 0
            fi
            
            # Find the actual library file in homebrew
            if [ ! -f "$lib_path" ]; then
              # Try to find it in homebrew
              local found_lib=$(find $HOMEBREW_PREFIX/opt $HOMEBREW_PREFIX/Cellar -name "$lib_name" -type f 2>/dev/null | head -n 1)
              if [ -z "$found_lib" ]; then
                echo "  Warning: Could not find $lib_name in homebrew"
                return 1
              fi
              lib_path="$found_lib"
            fi
            
            echo "  Copying $lib_name..."
            cp "$lib_path" "orc-gui.app/Contents/Frameworks/"
            chmod 644 "orc-gui.app/Contents/Frameworks/$lib_name"
            
            # Fix the library ID
            install_name_tool -id "@rpath/$lib_name" \
              "orc-gui.app/Contents/Frameworks/$lib_name" 2>/dev/null || true
            
            return 0
          }
          
          # Scan all bundled libraries for missing dependencies (multiple passes)
          for pass in {1..3}; do
            echo ""
            echo "Pass $pass: Scanning bundled libraries..."
            
            for LIB in orc-gui.app/Contents/Frameworks/*.dylib orc-gui.app/Contents/MacOS/orc-gui orc-gui.app/Contents/MacOS/orc-cli; do
              if [ ! -f "$LIB" ]; then
                continue
              fi
              
              # Get all homebrew dependencies
              for DEP in $(get_dependencies "$LIB"); do
                # Skip system libraries and already-relative paths
                if [[ "$DEP" == "/System/"* ]] || [[ "$DEP" == "/usr/lib/"* ]]; then
                  continue
                fi
                
                if [[ "$DEP" == "@rpath/"* ]]; then
                  # Extract library name from @rpath
                  DEP_NAME=$(echo "$DEP" | sed 's|@rpath/||')
                  
                  # Check if it exists in our bundle
                  if [ ! -f "orc-gui.app/Contents/Frameworks/$DEP_NAME" ]; then
                    echo "  $(basename $LIB) needs $DEP_NAME (not in bundle)"
                    # Try to find and copy it
                    FOUND_LIB=$(find $HOMEBREW_PREFIX/opt $HOMEBREW_PREFIX/Cellar -name "$DEP_NAME" -type f 2>/dev/null | head -n 1)
                    if [ -n "$FOUND_LIB" ]; then
                      copy_homebrew_lib "$FOUND_LIB"
                    fi
                  fi
                elif [[ "$DEP" == "$HOMEBREW_PREFIX/"* ]]; then
                  # Direct homebrew path reference
                  DEP_NAME=$(basename "$DEP")
                  
                  if [ ! -f "orc-gui.app/Contents/Frameworks/$DEP_NAME" ]; then
                    echo "  $(basename $LIB) needs $DEP_NAME from homebrew"
                    copy_homebrew_lib "$DEP"
                  fi
                  
                  # Fix the reference to use @rpath
                  install_name_tool -change "$DEP" "@rpath/$DEP_NAME" "$LIB" 2>/dev/null || true
                fi
              done
            done
          done
          
          echo ""
          echo "Fixing all libraries to use @loader_path for sibling dependencies..."
          for LIB in orc-gui.app/Contents/Frameworks/*.dylib; do
            if [ ! -f "$LIB" ]; then
              continue
            fi
            
            # Remove bad @loader_path/../lib rpath if it exists (common in homebrew libs)
            if otool -l "$LIB" | grep -A 2 "LC_RPATH" | grep -q "@loader_path/../lib"; then
              echo "  Removing bad @loader_path/../lib rpath from $(basename $LIB)..."
              install_name_tool -delete_rpath "@loader_path/../lib" "$LIB" 2>/dev/null || true
            fi
            
            # Add @loader_path rpath if not present
            if ! otool -l "$LIB" | grep -A 2 "LC_RPATH" | grep -q "@loader_path\$"; then
              install_name_tool -add_rpath "@loader_path" "$LIB" 2>/dev/null || true
            fi
            
            # Fix references to other bundled libraries
            for DEP in $(otool -L "$LIB" 2>/dev/null | tail -n +2 | awk '{print $1}'); do
              DEP_NAME=$(basename "$DEP")
              
              # If this dependency is in our bundle and not already using @rpath, fix it
              if [ -f "orc-gui.app/Contents/Frameworks/$DEP_NAME" ] && [[ "$DEP" != "@rpath/"* ]]; then
                install_name_tool -change "$DEP" "@rpath/$DEP_NAME" "$LIB" 2>/dev/null || true
              fi
            done
          done
          
          echo ""
          echo "Final dependency check - looking for missing dependencies..."
          MISSING_COUNT=0
          
          # Check executables and .dylib files
          for LIB in orc-gui.app/Contents/Frameworks/*.dylib orc-gui.app/Contents/MacOS/orc-gui orc-gui.app/Contents/MacOS/orc-cli; do
            if [ ! -f "$LIB" ]; then
              continue
            fi
            
            for DEP in $(otool -L "$LIB" 2>/dev/null | tail -n +2 | awk '{print $1}'); do
              # Skip system libraries and self-references
              if [[ "$DEP" == "/System/"* ]] || [[ "$DEP" == "/usr/lib/"* ]] || [[ "$DEP" == "$LIB" ]]; then
                continue
              fi
              
              # Skip Qt framework references (they're in Frameworks/)
              if [[ "$DEP" == *".framework/"* ]]; then
                continue
              fi
              
              if [[ "$DEP" == "@rpath/"* ]]; then
                DEP_NAME=$(echo "$DEP" | sed 's|@rpath/||')
                if [ ! -f "orc-gui.app/Contents/Frameworks/$DEP_NAME" ]; then
                  echo "  WARNING: $(basename $LIB) needs $DEP_NAME which is NOT bundled!"
                  MISSING_COUNT=$((MISSING_COUNT + 1))
                fi
              elif [[ "$DEP" == "$HOMEBREW_PREFIX/"* ]]; then
                echo "  WARNING: $(basename $LIB) has hard-coded homebrew path: $DEP"
                MISSING_COUNT=$((MISSING_COUNT + 1))
              fi
            done
          done
          
          # Also check Qt frameworks for .dylib dependencies
          shopt -s nullglob  # Make globs that don't match expand to nothing instead of literal string
          for FRAMEWORK in orc-gui.app/Contents/Frameworks/*.framework/Versions/A/* orc-gui.app/Contents/Frameworks/*.framework/*; do
            # Skip if not a file, or if it's a directory, or common non-binary paths
            if [ ! -f "$FRAMEWORK" ] || [[ "$FRAMEWORK" == *"Resources"* ]] || [[ "$FRAMEWORK" == *"Headers"* ]] || [[ "$FRAMEWORK" == *"Versions"* ]]; then
              continue
            fi
            
            for DEP in $(otool -L "$FRAMEWORK" 2>/dev/null | tail -n +2 | awk '{print $1}'); do
              # Skip system libraries, framework references, and self-references
              if [[ "$DEP" == "/System/"* ]] || [[ "$DEP" == "/usr/lib/"* ]] || [[ "$DEP" == *".framework/"* ]] || [[ "$DEP" == "$FRAMEWORK" ]]; then
                continue
              fi
              
              if [[ "$DEP" == "@rpath/"* ]]; then
                DEP_NAME=$(echo "$DEP" | sed 's|@rpath/||')
                if [ ! -f "orc-gui.app/Contents/Frameworks/$DEP_NAME" ]; then
                  echo "  WARNING: $(basename $FRAMEWORK) needs $DEP_NAME which is NOT bundled!"
                  MISSING_COUNT=$((MISSING_COUNT + 1))
                fi
              elif [[ "$DEP" == "$HOMEBREW_PREFIX/"* ]]; then
                echo "  WARNING: $(basename $FRAMEWORK) has hard-coded homebrew path: $DEP"
                MISSING_COUNT=$((MISSING_COUNT + 1))
              fi
            done
          done
          shopt -u nullglob  # Restore default behavior
          
          if [ $MISSING_COUNT -gt 0 ]; then
            echo ""
            echo "ERROR: Found $MISSING_COUNT missing or incorrectly referenced dependencies!"
            echo ""
            echo "Listing all bundled .dylib files:"
            ls -lh orc-gui.app/Contents/Frameworks/*.dylib 2>/dev/null || echo "No .dylib files found"
            echo ""
            echo "Listing all bundled frameworks:"
            ls -d orc-gui.app/Contents/Frameworks/*.framework 2>/dev/null || echo "No frameworks found"
            exit 1
          fi
          
          echo ""
          echo "✓ All dependencies verified and bundled successfully"
          echo ""
          echo "Final bundle contents:"
          echo "Bundled .dylib libraries ($(ls -1 orc-gui.app/Contents/Frameworks/*.dylib 2>/dev/null | wc -l | xargs)):"
          ls -1 orc-gui.app/Contents/Frameworks/*.dylib 2>/dev/null | xargs -n 1 basename | sort
          echo ""
          echo "Bundled frameworks ($(ls -d1 orc-gui.app/Contents/Frameworks/*.framework 2>/dev/null | wc -l | xargs)):"
          ls -d1 orc-gui.app/Contents/Frameworks/*.framework 2>/dev/null | xargs -n 1 basename
      
      - name: Code sign app bundle (ad-hoc)
        run: |
          # Clean extended attributes and resource forks that interfere with codesigning
          echo "Cleaning extended attributes and resource forks..."
          xattr -cr "orc-gui.app"
          find "orc-gui.app" -type f -name "._*" -delete 2>/dev/null || true
          
          codesign --force --deep --sign - "orc-gui.app"
          codesign --verify --verbose=2 "orc-gui.app"
      
      - name: Create CLI symlink installer script
        if: inputs.version != 'dev'
        run: |
          cat > "Install CLI Tool.command" << 'EOF'
          #!/bin/bash
          # This script creates a symlink to orc-cli in /usr/local/bin
          
          echo "Installing orc-cli to /usr/local/bin..."
          
          APP_PATH="/Applications/orc-gui.app"
          
          if [ ! -d "$APP_PATH" ]; then
            echo "Error: orc-gui.app not found in /Applications"
            echo "Please drag orc-gui to /Applications first, then run this script again."
            read -p "Press Enter to exit..."
            exit 1
          fi
          
          sudo mkdir -p /usr/local/bin
          
          if [ -L /usr/local/bin/orc-cli ]; then
            sudo rm /usr/local/bin/orc-cli
          fi
          
          sudo ln -s "$APP_PATH/Contents/MacOS/orc-cli" /usr/local/bin/orc-cli
          
          if [ $? -eq 0 ]; then
            echo "✓ Successfully installed orc-cli!"
            echo "You can now run 'orc-cli' from anywhere in the terminal."
          else
            echo "✗ Failed to install orc-cli"
            exit 1
          fi
          
          read -p "Press Enter to exit..."
          EOF
          
          chmod +x "Install CLI Tool.command"
      
      - name: Create DMG
        run: |
          VERSION="${{ inputs.version }}"
          
          mkdir -p dmg-staging
          cp -R "orc-gui.app" dmg-staging/
          
          if [ "$VERSION" != "dev" ] && [ -f "Install CLI Tool.command" ]; then
            cp "Install CLI Tool.command" dmg-staging/
          fi
          
          # Create appropriate README
          if [ "$VERSION" = "dev" ]; then
            cat > "dmg-staging/README.txt" << 'EOF'
          Decode Orc - Development Build
          ===============================
          
          1. Drag "orc-gui" to your Applications folder
          2. Right-click "orc-gui" and select "Open" (first time only)
          3. CLI tool is located inside the app at: orc-gui.app/Contents/MacOS/orc-cli
          
          EOF
          else
            cat > "dmg-staging/README.txt" << 'EOF'
          Decode Orc - Installation Instructions
          ========================================
          
          1. Drag "orc-gui" to your Applications folder
          
          2. To launch the GUI:
             - Right-click "orc-gui" in Applications and select "Open"
             - Click "Open" in the security dialog
             - After first launch, you can double-click normally
          
          3. To install the CLI tool (optional):
             - Double-click "Install CLI Tool" in this DMG
             - Enter your password when prompted
             - You can then run "orc-cli" from any terminal
          
          EOF
          fi
          
          # Copy volume icon and set attributes
          cp .VolumeIcon.icns dmg-staging/.VolumeIcon.icns
          SetFile -a C dmg-staging/.VolumeIcon.icns 2>/dev/null || true
          
          echo "Verifying DMG staging contents:"
          ls -la dmg-staging/
          echo ""
          echo "App icon verification:"
          ls -lh dmg-staging/orc-gui.app/Contents/Resources/*.icns
          
          # Set DMG filename
          if [ "$VERSION" = "dev" ]; then
            DMG_NAME="decode-orc-macOS.dmg"
          else
            DMG_NAME="decode-orc-$VERSION-macOS.dmg"
          fi
          
          echo "Creating DMG: $DMG_NAME"
          create-dmg \
            --volname "Decode Orc" \
            --volicon ".VolumeIcon.icns" \
            --window-pos 200 120 \
            --window-size 800 400 \
            --icon-size 100 \
            --icon "orc-gui.app" 200 185 \
            --app-drop-link 600 185 \
            --hide-extension "orc-gui.app" \
            "$DMG_NAME" \
            "dmg-staging" || hdiutil create -volname "Decode Orc" -srcfolder "dmg-staging" -ov -format UDZO "$DMG_NAME"
          
          echo "✓ DMG created successfully"
          ls -lh "$DMG_NAME"
      
      - name: Set artifact name
        id: set-artifact-name
        run: |
          if [ "${{ inputs.version }}" = "dev" ]; then
            echo "name=decode-orc-macos-dmg" >> $GITHUB_OUTPUT
          else
            echo "name=macos-dmg" >> $GITHUB_OUTPUT
          fi
      
      - name: Upload DMG artifact
        uses: actions/upload-artifact@v4
        with:
          name: ${{ steps.set-artifact-name.outputs.name }}
          path: decode-orc-*.dmg
          retention-days: 7

  build-flatpak-package:
    name: Build Flatpak Package
    runs-on: ubuntu-latest
    container:
      image: ghcr.io/flathub-infra/flatpak-github-actions:kde-6.8
      options: --privileged
    outputs:
      artifact-name: ${{ steps.set-artifact-name.outputs.name }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          lfs: true
      
      - name: Set bundle name
        id: set-bundle-name
        run: |
          VERSION="${{ inputs.version }}"
          if [ "$VERSION" = "dev" ]; then
            echo "bundle=decode-orc.flatpak" >> $GITHUB_OUTPUT
          else
            echo "bundle=decode-orc-$VERSION.flatpak" >> $GITHUB_OUTPUT
          fi
      
      - name: Build Flatpak
        uses: flatpak/flatpak-github-actions/flatpak-builder@v6
        with:
          bundle: ${{ steps.set-bundle-name.outputs.bundle }}
          manifest-path: io.github.simoninns.decode-orc.yml
          cache-key: flatpak-builder-${{ github.sha }}
          upload-artifact: false
      
      - name: Set artifact name
        id: set-artifact-name
        run: |
          if [ "${{ inputs.version }}" = "dev" ]; then
            echo "name=decode-orc-flatpak" >> $GITHUB_OUTPUT
          else
            echo "name=flatpak-bundle" >> $GITHUB_OUTPUT
          fi
      
      - name: Upload Flatpak bundle
        uses: actions/upload-artifact@v4
        with:
          name: ${{ steps.set-artifact-name.outputs.name }}
          path: decode-orc*.flatpak
          retention-days: 7
