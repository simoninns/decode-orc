/*
 * File:        tbc_yc_video_field_representation.h
 * Module:      orc-core
 * Purpose:     TBC YC (separate Y and C) video field representation
 *
 * SPDX-License-Identifier: GPL-3.0-or-later
 * SPDX-FileCopyrightText: 2025-2026 Simon Inns
 */


#ifndef TBC_YC_VIDEO_FIELD_REPRESENTATION_H
#define TBC_YC_VIDEO_FIELD_REPRESENTATION_H

#include "video_field_representation.h"
#include "tbc_reader.h"
#include "tbc_metadata.h"
#include "tbc_audio_efm_handler.h"
#include "lru_cache.h"
#include "buffered_file_io.h"
#include <memory>
#include <fstream>
#include <mutex>

namespace orc {

// TODO: Observer system refactored - old observer friend declarations removed

/**
 * @brief Concrete implementation of VideoFieldRepresentation backed by separate Y and C TBC files
 * 
 * This class provides access to YC sources where luma (Y) and chroma (C) are captured
 * in separate files (.tbcy and .tbcc), as opposed to composite sources where Y+C are
 * modulated together in a single .tbc file.
 * 
 * YC sources are typically from color-under formats like VHS or Betamax, where the
 * chroma is frequency-shifted (color-under) and recorded separately from luma.
 * 
 * IMPORTANT: YC sources should not be confused with "component video" (Y/Pb/Pr or RGB).
 * YC sources contain:
 * - Y: Pure luma samples (clean, no comb filter needed)
 * - C: Modulated chroma samples (needs demodulation but not Y/C separation)
 * 
 * File format:
 * - .tbcy: Luma samples (16-bit, one sample per time position)
 * - .tbcc: Chroma samples (16-bit, modulated, one sample per time position)
 * - .tbc.db: Shared metadata (SQLite database, same format as composite)
 * 
 * Properties:
 * - Y and C files have IDENTICAL field counts and IDENTICAL geometry
 * - Each Y sample has a CORRESPONDING C sample at the same position
 * - SINGLE dropout map in metadata applies to both channels
 * 
 * ARCHITECTURAL BOUNDARY - YC SOURCE STAGE RESPONSIBILITIES:
 * ==========================================================
 * 
 * INTERNAL (private to this stage):
 * - Reads TBC metadata from .tbc.db files via TBCMetadataReader
 * - Accesses Y samples from .tbcy files via TBCReader (Y)
 * - Accesses C samples from .tbcc files via TBCReader (C)
 * - Uses metadata internally for configuration and optimization
 * 
 * EXTERNAL INTERFACE (for downstream stages):
 * - has_separate_channels(): Returns true (this is a YC source)
 * - get_line_luma(), get_line_chroma(): Returns Y and C data separately
 * - get_observations(): Returns observations generated by running observers
 * - get_*_hint(): Returns hints derived from TBC metadata
 * 
 * CRITICAL: Downstream stages must NEVER access TBC metadata directly.
 * All metadata information must flow through either:
 * 1. Observations (via get_observations()) - from analyzing video data
 * 2. Hints (via get_*_hint()) - from metadata
 */
class TBCYCVideoFieldRepresentation : public VideoFieldRepresentation,
                                       public TBCAudioEFMHandler::MetadataProvider {
public:
    /**
     * @brief Create from separate Y and C TBC files with shared metadata
     * 
     * @param y_reader Shared reader for Y (luma) TBC file
     * @param c_reader Shared reader for C (chroma) TBC file
     * @param metadata_reader Shared reader for metadata database
     * @param artifact_id Unique identifier for this artifact
     * @param provenance Provenance information
     */
    TBCYCVideoFieldRepresentation(
        std::shared_ptr<TBCReader> y_reader,
        std::shared_ptr<TBCReader> c_reader,
        std::shared_ptr<TBCMetadataReader> metadata_reader,
        ArtifactID artifact_id,
        Provenance provenance
    );
    
    ~TBCYCVideoFieldRepresentation() override = default;
    
    // Prevent copying - represents large video data, share via shared_ptr instead
    TBCYCVideoFieldRepresentation(const TBCYCVideoFieldRepresentation&) = delete;
    TBCYCVideoFieldRepresentation& operator=(const TBCYCVideoFieldRepresentation&) = delete;
    
    // Prevent moving - instances should be managed via shared_ptr
    TBCYCVideoFieldRepresentation(TBCYCVideoFieldRepresentation&&) = delete;
    TBCYCVideoFieldRepresentation& operator=(TBCYCVideoFieldRepresentation&&) = delete;
    
    // VideoFieldRepresentation interface
    FieldIDRange field_range() const override;
    size_t field_count() const override;
    bool has_field(FieldID id) const override;
    
    std::optional<FieldDescriptor> get_descriptor(FieldID id) const override;
    
    // Composite access (not supported for YC sources)
    const sample_type* get_line(FieldID id, size_t line) const override;
    std::vector<sample_type> get_field(FieldID id) const override;
    
    // YC dual-channel access (the primary interface for YC sources)
    bool has_separate_channels() const override { return true; }
    
    const sample_type* get_line_luma(FieldID id, size_t line) const override;
    const sample_type* get_line_chroma(FieldID id, size_t line) const override;
    
    std::vector<sample_type> get_field_luma(FieldID id) const override;
    std::vector<sample_type> get_field_chroma(FieldID id) const override;
    
    std::vector<DropoutRegion> get_dropout_hints(FieldID id) const override;
    std::optional<FieldParityHint> get_field_parity_hint(FieldID id) const override;
    std::optional<FieldPhaseHint> get_field_phase_hint(FieldID id) const override;
    std::optional<ActiveLineHint> get_active_line_hint() const override;
    
    std::optional<VideoParameters> get_video_parameters() const override {
        return video_params_;
    }
    
    // Audio interface
    uint32_t get_audio_sample_count(FieldID id) const override;
    std::vector<int16_t> get_audio_samples(FieldID id) const override;
    bool has_audio() const override;
    
    /**
     * @brief Set the PCM audio file path
     * @param pcm_path Path to .pcm audio file
     * @return true if file opened successfully, false otherwise
     */
    bool set_audio_file(const std::string& pcm_path);
    
    // EFM interface
    uint32_t get_efm_sample_count(FieldID id) const override;
    std::vector<uint8_t> get_efm_samples(FieldID id) const override;
    bool has_efm() const override;
    
    /**
     * @brief Set the EFM data file path
     * @param efm_path Path to .efm file
     * @return true if file opened successfully, false otherwise
     */
    bool set_efm_file(const std::string& efm_path);
    
    std::string type_name() const override { return "TBCYCVideoFieldRepresentation"; }
    
private:
    // TBC-specific accessors - private to enforce architectural boundaries
    const VideoParameters& video_parameters() const { return video_params_; }
    std::shared_ptr<TBCMetadataReader> get_metadata_reader() const { return metadata_reader_; }
    std::optional<FieldMetadata> get_field_metadata(FieldID id) const;
    
    // TODO: Observer system refactored - observers now access data via public interface
    
    std::shared_ptr<TBCReader> y_reader_;  // Luma channel reader
    std::shared_ptr<TBCReader> c_reader_;  // Chroma channel reader
    std::shared_ptr<TBCMetadataReader> metadata_reader_;
    
    VideoParameters video_params_;
    std::map<FieldID, FieldMetadata> field_metadata_cache_;
    
    // Audio and EFM handling delegated to shared handler
    std::unique_ptr<TBCAudioEFMHandler> audio_efm_handler_;
    
    // Separate line data caches for Y and C channels
    // Cache size: 500 fields × ~1.4MB/field × 2 channels = ~1.4GB max for preview navigation
    mutable LRUCache<FieldID, std::vector<sample_type>> y_field_data_cache_;
    mutable LRUCache<FieldID, std::vector<sample_type>> c_field_data_cache_;
    static constexpr size_t MAX_CACHED_TBC_FIELDS = 500;
    
    void ensure_video_parameters();
    void ensure_field_metadata();
    
    // MetadataProvider interface implementation
    std::map<FieldID, FieldMetadata>& get_field_metadata_cache() override {
        return field_metadata_cache_;
    }
};

/**
 * @brief Factory function to create TBCYCVideoFieldRepresentation from separate Y and C files
 * 
 * This function:
 * - Validates that Y and C files have matching field counts
 * - Validates that geometry matches from metadata
 * - Creates dual TBCReader instances (one for Y, one for C)
 * - Returns a TBCYCVideoFieldRepresentation
 * 
 * @param y_filename Path to .tbcy (luma) file
 * @param c_filename Path to .tbcc (chroma) file
 * @param metadata_filename Path to .tbc.db metadata file
 * @param pcm_filename Optional path to .pcm audio file
 * @param efm_filename Optional path to .efm EFM data file
 * @return Shared pointer to representation, or nullptr on failure
 */
std::shared_ptr<TBCYCVideoFieldRepresentation> create_tbc_yc_representation(
    const std::string& y_filename,
    const std::string& c_filename,
    const std::string& metadata_filename,
    const std::string& pcm_filename = "",
    const std::string& efm_filename = ""
);

} // namespace orc

#endif // TBC_YC_VIDEO_FIELD_REPRESENTATION_H
